'''
> Платформенная сопрограмма - функция, определенная с помощью конструкции async def. Мы можем делегировать работу от одной
платформенной сопрограммы другой, воспользовавшись клюевым словом await, по аналогии с тем, как классические сопрограммы уступают
управление с помощью предложения yield from. Предложение async def всегда определяет платформенную спорограмму, даже
если в ее теле не встречается ключевое слово await. Слово await нельзя использовать вне платформенной сопрограммы.

> Классическая сопрограмма - генераторная функция, которая потребляет данные, отправленные ей с помозью вызовов my_coro.send(data),
и читает эти данные, используя yield в выражении. Классическая сопрограмма может делигировать работу другой классической сопрограмме
с помощью предложения yield from. Классические сопрограммы не приводятся в действие словом await и более не поддерживаются
библиотекой asyncio.

> Генераторные сопрограммы - генераторная фукнция, снабженная декоратором @types.coroutine. Этот декоратор делает генератор
совместимым с новым ключевым словом await.

> Асинхронный генератор - генераторная функция, определенная с помощью конструкции async def и содержащая в теле yield.
Она возвращает асинхронный объект-генератор, предоставляющий метод __anext__ для асинхронного получения следующего значения.
'''

# Пример использования asyncio: проверка доменных имен
'''
Допустим, вы собираетесь начать новый блог, посвященный Python, и планируете зарегистрировать домен, содержащий какое-нибудь 
клюевое слово Python и имеющий суффикс .DEV, например AWAIT.DEV.
'''

import asyncio
import socket
from keyword import kwlist

MAX_KEYWORD_LEN = 4 # Задать максимальную длину ключевого слова в доменном имени, поскольку чем оно короче, тем лучше.

async def probe(domain: str) -> tuple[str, bool]:
    '''Функция probe возвращает кортеж, содержащий доменное имя и булево знаение; True означает, что имя успешно разрешено.
    Возврат доменного имени упрощает отображение результатов.'''
    loop = asyncio.get_running_loop() # Получить ссылку на цикл событий asyncio для будущего использования.
    try:
        await loop.getaddrinfo(domain, None) # Метод-сопрограмма loop.getaddrinfo(...) возвращает 5-кортеж параметров для
                                             # подключения к указанному адресу через сокет. В этом примере нам результат не нужен.
                                             # Если мы получили кортеж, значит, имя разрешено, в противном случае - нет.
    except socket.gaierror:
        return (domain, False)
    return (domain, True)

async def main() -> None: # Должна быть сопрограммой, чтобы в ней можно было использовать await
    names = (kw for kw in kwlist if len(kw) <= MAX_KEYWORD_LEN) # Генератор, отдающий ключевые слова Python длиной не более MAX_KEYWORD_LEN.
    domains = (f'{name}.dev'.lower() for name in names) # Генератор, отдающий доменные имена с суффиксом .dev.
    coros = [probe(domain) for domain in domains] # Построим список объектов сопрограмм, вызывая сопрограмму probe с каждым аргументом domain.
    for coro in asyncio.as_completed(coros): # asyncio.as_completed - генератор, отдающий переданные ему сопрограммы в порядке
                                             # их завершения, а не в порядке подачи. Он похож на функцию futures.as_completed.
        domain, found = await coro # В этот момент вы знаем, что сопрограмма завершилась, потому то так работает as_completed.
                                   # Поэтому выражение await не заблокирует выполнение, но оно все равно необходимо, чтобы получить
                                   # результат от coro. Если coro возбуждала необработанное исключение, то оно будет заново
                                   # возбуждено в этой точке.
        mark = '+' if found else ' '
        print(f'{mark} {domain}')

if __name__ == '__main__':
    asyncio.run(main()) # asyncio.run запускает цикл событий и возвращает управление только после выхода из него.
                        # Это типичный паттерн для скриптов, в которых используется asyncio: реализовать main как сопрограмму и
                        # выполнить ее внутри блока if __name__ == '__main__':.

'''
Функция asyncio.get_running_loop была добавлена для использования внутри сопрограмм, как показано в probe. Если работающего 
цикла нет, то она возбуждает исключение RuntimeError. Ее реализация проще и быстрее, чем реализация функции asyncio.get_event_loop, 
которая может при необходимости запустить цикл событий. asyncio.get_event_loop объявлена нерекомендуемой и в конечном итоге станет
псевдонимом asyncio.get_running_loop.
'''

# Предложенный Гвидо способ чтения асинхронного кода
'''
Общий прием - прищуриться и сделать вид, что ключевых слов async и await нет. Тогда вы моймете, что сопрограммы читаются, как
старые добрые последовательные фукнции, с тем отличием, что волшебным образом никогда не блокируется выполнение сопрограммы.

Конструкция await loop.getaddrinfo(...) позволяет избежать блокирования, потому что await приостанавливает текущий объект сопрограммы.
Например, во время выполнения сопрограммы probe('if.dev') создается новый объект сопрограммы с помощью вызова 
getaddrinfo('if.dev', None). Его ожидание запускает низкоуровневый запрос addrinfo и уступает управление циклу событий, а не 
приостановленной сопрограмме probe('if.dev'). Затем цикл событий может передать управление другим ожидающим объектам сопрограмм,
например probe('or.dev').
Когда цикл событий получитответ от запроса getaddrinfo('if.dev', None), этот объект сопрограммы возобновляется и возвращает 
управление probe('if.dev'), которая была приостановлена в await, а затем может обработать возможное исключение и вернуть кортеж
с результатами.
'''

# Загрузка файлов с помощью asyncio и httpx

import asyncio
import time

from pathlib import Path
from httpx import AsyncClient
from typing import Callable

POP20_CC = ('CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR').split()

BASE_URL = 'https://www.fluentpython.com/data/flags'
DEST_DIR = Path('downloaded')

def save_flag(img: bytes, filename: str) -> None:
    '''Скопировать img (последовательность байтов) в файл с именем filename в каталоге DEST_DIR'''
    (DEST_DIR / filename).write_bytes(img)

def download_many(cc_list: list[str]) -> int:
    '''Это должна быть обычная функция, а не сопрограмма, чтобы ее можно было передать и вызвать из функции main.
    Выполнять цикл событий, приводящий в действие объект сопрограммы supervisor(cc_list), пока тот не вернет управление.
    Эта строка блокирует выполнение на все время работы цикла событий. Ее результатом является значение, возвращенное supervisor.'''
    return asyncio.run(supervisor(cc_list))

async def download_one(client: AsyncClient, cc: str) -> str:
    '''Должна быть платформенной сопрограммой, чтобы она могла вызвать await для сопрограммы get_flag, которая выполняет
    http-запрос. Затем она отображает загруженный флаг и сохраняет изображение.'''
    image = await get_flag(client, cc)
    save_flag(image, f'{cc}.gif')
    print(cc, end=' ', flush=True)
    return cc

async def get_flag(client: AsyncClient, cc: str) -> bytes: # Должна получить AsyncClient, чтобы сделать запрос.
    url = f'{BASE_URL}/{cc}/{cc}.gif'.lower()
    resp = await client.get(url, timeout=6.1, follow_redirects=True) # Метод get экземпляра httpx.AsyncClient возвращает объект
                                                                     # ClientResponse, который заодно является асинхронным
                                                                     # контекстным менеджером.
    return resp.read() # Операции сетевого ввода-вывода реализованы в виде методов-сопрограмм, чтобы их можно было асинхронно
                       # вызвать из цикла событий asyncio.

async def supervisor(cc_list: list[str]) -> int:
    async with AsyncClient() as client: # Асинхронные операции HTTPX-клиета в httpx - это методы класса AsyncClient, который также
                                        # является асинхронным контекстным менеджером, т.е. контекстным менеджером с асинхронными
                                        # методами инициализации и очистки.
        to_do = [download_one(client, cc) for cc in sorted(cc_list)] # Построить список объектов сопрограм, вызвав сопрограмму
                                                                     # download_one по разу для каждого флага.
        res = await asyncio.gather(to_do) # Ждать завершения сопрограммы asyncio.gather, которая принимает один или несколько
                                          # допускающих ожидание аргументов, ждет их завершения, а затем возвращает список
                                          # результатов заданных объектов в том порядке, в каком они подавались на вход.

    return len(res) # Возвращает длину списка, возвращенного функцией asyncio.gather.

def main(downloader: Callable[[list[str]], int]) -> None:
    '''При вызове main необходимо указывать функцию, которая производит загрузку;
    таким образом, main можно будет использовать, как библиотечную функцию, способную работать и с другими
    реализациями download_many в примерах threadpool и asyncio.'''
    DEST_DIR.mkdir(exist_ok=True) # Создать каталог DEST_DIR, если необходимо; не возбуждать исключение, если каталог уже существует
    t0 = time.perf_counter()
    count = downloader(POP20_CC)
    elapsed = time.perf_counter() - t0
    print(f'\n{count} downloads in {elapsed:.2f}s')

if __name__ == '__main__':
    main(download_many)

# Секрет платформенных сопрограмм: скромные генераторы

