# Термины
'''
Конкурентность - способность обрабатывать несколько задач, чередуя выполнение или параллельно (если это возможно),
так что каждая задача в конечном итоге успешно доходит до конца или завершается с ошибкой. Одноядерный процессор
допускает конкурентность, если работает под управлением планировщика ОС, который чередует выполнение ожидающих задач.
Встречается также название многозадачность.

Параллелизм - способность выполнять несколько вычислений одновременно. Для этого необходим многоядерный процессор,
несколько процессоров, графический процессор или кластер из нескольких компьютеров.

Единица выполнения - общий термин для объектов, выполняющих код конкурентно, каждый из которых имеет независимые от других
состояния и стек вызовов. Python поддерживает три вида единиц выполнения: процессы, потоки и сопрограммы.

Процесс - экземпляр компьютерной программы во время ее выполнения, которому выделены память и квант процессорного времени.
Современные операционные системы для настольных компьютеров без труда управляют сотнями конкурентных процессов,
при этом каждый процесс изолирован в собственном адресном пространстве. Процессы взаимодействуют посредством каналов,
советов или отображенных на память файлов - все они могут передавать только "голые" байты. Чтобы передать объект Python из
одного процесса в другой, его необходимо сериализовать в виде последовательности байтов. Это дорого, и не все объекты
допускают сериализацию. Процесс может порождать подпроцессы, или дочерние процессы. Они изолированны как друг от друга,
так и от родительского процесса. Процессы допускают вытесняющую многозадачность: планировщик ОС периодически вытесняет, т.е.
приостанавливает процесс, чтобы дать возможность поработать остальным. Это означает, что зависший процесс не может подвесить
всю системы - теоретически.

Поток - единица выполнения внутри одного процесса. Сразу после запуска процесс содержит один - главный - поток.
Вызывая системные API, процесс может создавать дополнительные потоки, которые будут работать конкурентно.
Потоки внутри одного процесса разделяют общее пространство памяти, в которой находятся активные объекты Python.
Это позволяет потокам совместно использовать данные, но может приводить к повреждению данных, если сразу несколько
потоков пытаются обновить один и тот же объект. Как и процессы, потоки допускают вытесняющую многозадачность под
управлением планировщика ОС. Поток потребляет меньше ресурсов, чем процесс, для выполнения одной и той же работы.

Сопрограмма - функция, которая может приостановить свое выполнение и продолжить позже. В Python классиеческие сопрограммы
стоятся на основе генераторных функций, а платформенные определяются с помощью ключевых слов async def.
В Python сопрограммы обычно исполняются в одном потоке под управлением цикла событий, который работает в том же потоке.
Такие каркасы асинхронного программирования, как asyncio, Cyrio или Trio, предоставляют цикл событий и поддерживающие библиотеки
для реализации неблокирующего ввода-вывода на основе сопрограмм. Сопрограммы поддерживают кооперативную многозадачность:
каждая сопрограмма должна явно уступать процессор с помощью ключевого слова yield или await, чтобы другие части программы
могли работать конкурентно (но не параллельно). Это означает, что любой блокирующий код внутри сопрограммы блокирует
выполнение цикла событий всех остальных сопрограмм - в отличие от вытесняющей многозадачности, которую поддерживают процессы
и потоки. С другой стороны, сопрограммы потребляют меньше ресурсов по сравнению с процессами и потоками, выполняющими ту же работу.

Очередь - струтура данных, позволяющая помещать и извлекать элементы, обычно в порядке FIFO: первым пришел, первым ушел.
Очереди дают возможность единицам выполнения обмениваться данными и управляющими сообщениями, например кодами ошибок
и сигналами завершения. Реализация очереди зависит от модели конкурентности: пакет queue в стандартной библиотеке Python
предоставляет классы очередей для поддержки потоков, тогда как пакеты multiprocessing и asyncio реализуют собственные классы
очередей. Пакеты queue и asyncio включают также очереди, обсуживаемые не в порядке FIFO: LifeQueue и PriorityQueue.

Блокировка - объект, который единицы выполнения могут использовать для синхронизации своих действий, чтобы избежать
повреждения данных. Во время обновления разделяемой структуры данных исполняемый код должен удерживать ассоциированную
блокировку. Это служит для остальных частей прогрммы сигналом, что нужно подождать, пока блокировка освободится, и только
потом обращаться к той же структуре данных. Простейший вид блокировки называется мьютексом (mutual exclusion - взаимное
исключение). Реализация блокировки зависит от модели конкурентности.

Состязание - спор за ограниченный ресурс. Состязание возникает, когда несколько единиц выполнения пытаются обратиться к
разделяемому ресурсу, например блокировке или хранилищу. Бывает также состязание за процессор, когда счетные процессы
или потоки должны ждать, пока планировщик ОС выделит им долю процессорного времени.
'''

# Процессы, потоки и знаменитая блокировка GIL в Python
'''
Ниже описано, как вышеописанные термины применяются в контексте программирования на Python.

1. Каждый экземпляр интерпретатора Python является процессом. Дополнительные процессы Python можно запускать с помощью
библиотек multiprocessing или concurrent.futures. Библиотека subprocess предназначена для запуска процессов, в которых
будут исполняться внешние программы, написанные на любом языке.

2. Интерпретатор Python использует единственный поток, в котором выполняется и пользовательская программа и сборщик мусора.
Для запуска дополнительных потоков предназначены библиотеки threading и concurrent.futures.

3. Доступ к счетчикам ссылок на объекты и другим внутренним структурам интерпретатора контролируется глобальной блокировкой
интерпретатора (Global Interpreter Lock - GIL). Только один поток Python может удерживать GIL в каждый момент времени.
Это означает, что только один поток может выполнять Python-код, и от числа процессорных ядер это не зависит. 

4. Чтобы помешать потоку Python удерживать GIL бесконечно, итерпретатор байт-кода Python периодически (по умолчанию раз 
в 5 миллисекунд) приостанавливает текущий поток и тем самым освобождает GIL. Поток может попытаться снова захватить GIL, но
если его ждут другие потоки, то планировщик ОС, возможно, выберет один из них.

5. Программист, пишущий на Python, не может управлять GIL. Но встроенная функция или расширение, написанное на C или на любом
другом языке, имеющем интерфейс к Python на уровне C API, может освободить GIL во время выполнения длительной задачи.

6. Любая стандартная библиотечная функция Python, делающая системный вызов, освобождает GIL. Сюда относятся все функции,
выполняющие дисковый ввод-вывод, сетевой ввод-вывод, а так же time.sleep(). Многие счетные функции в библиотеках 
NumPy/SciPy, а также функции сжатия и распаковки из модулей zlib и bz2 также освобождают GIL.

7. Расширения, интегрированные на уровне интерфейса между Python и C, могут тоже запускать потоки, не управляемые Python, 
на которые действие GIL не распространяется. Такие свободные от GIL потоки в общем случае не могут изменять объекты Python,
но могут читать и записывать память объектов, поддерживающих протокол буфера, например bytearray, array.array и массивы NumPy.

8. Влияние GIL на сетевое программирование с помощью потоков Python сравнительно невелико, потому что функции ввода-вывода
освобождают GIL, а чтение или запись в сеть всегда подразумевает высокую задержку по сравнению с чтением-записью в память.
Следовательно, каждый отдельный поток все равно тратит много времени на ожидание, так что их выполнение можно чередовать без
заметного снижения общей пропускной способности.

9. Состязание за GIL замедляет работу счетных потоков в Python. В таких случаях последовательный однопоточный код проще и быстрее.

10. Для выполнения счетного Python-кода на нескольких ядрах нужно использовать несколько процессов Python. 
'''

# Конкурентная программа Hello World
# Анимированный индикатор с потоками

import itertools
import time

from threading import Thread, Event

def spin(msg: str, done: Event) -> None:
    for char in itertools.cycle(r'\/\-'):
        status = f'\r{char} {msg}'
        print(status, end='')
        if done.wait(.3):
            '''Функция Event.wait(timeout=None) возвращает True, когда другой поток установил событие;
            если же истек тайм-аут timeout, то он возвращает False. Тайм-аут .1s означает, что анимация
            производится 10 кадров в секунду.'''
            blanks = ' ' * len(status)
            print(f'\r{blanks}\r', end='')
            break
        blanks = ' ' * len(status)
        print(f'\r{blanks}\r', end='')

def slow() -> int:
    '''Вызывается из главного потока. Представьте, что это вызов медленного API по сети.
    Вызов sleep блокирует главный поток, но GIL при этом освобождается, поэтому поток индикатора продолжает работать.'''
    time.sleep(5)
    return 42

'''
Класс threading.Event - самый простой из имеющихся в Python механизмов сигнализации для координации потоков.
В экзампляре Event имеется внутренний булевый флаг, который первоначально равен False. Вызов Event.set() устанавливает 
этот флаг в True. Если флаг равен False, то поток, вызвавший Event.wait(), блокируется до тех пор, пока какой-нибудь 
другой поток не вызовет Event.set(), и в этот момент Event.wait() возвращает True. Если функции Event.wait(s) передан
тайм-аут в секундах, то по истеении тайм-аута этот вызов вернет False (или True, если раньше какой-то другой поток
вызовет Event.set()).
'''

def supervisor() -> int: # Возврашает результат slow()
    done = Event()
    spinner = Thread(target=spin, args=('thinking!', done)) # Чтобы задать новый экземплятр Thread, задайте функцию в именованном
                                                            # аргументе target, а необходимые ей позиционные аргументы передавайте
                                                            # в кортеже args
    print(f'spinner object: {spinner}') # Отобразить объект spinner
    spinner.start() # Запустить поток spinner
    result = slow() # Вызвать функцию slow(), которая блокирует поток main. Тем временем второй поток выполняет анимацию индикатора.
    done.set() # Установить флаг Event в True; в результате чего произойдет выход из цикла for в функции spin
    spinner.join() # Ждать завершения потока spinner
    return result

def main() -> None:
    result = supervisor()
    print(f'Answer: {result}')

main()